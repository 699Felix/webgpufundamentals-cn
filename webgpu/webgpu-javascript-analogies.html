<style>
  pre { margin: 0; }
</style>
<body></body>
<script type="module">

// Wrap console log so we don't have to explain some `log` function.
console.log = (origFn => {
  return function(...args) {
    const elem = document.createElement('pre');
    elem.textContent = args.join(' ');
    document.body.appendChild(elem);
    origFn(...args);
  };
})(console.log.bind(console));

section('run by count');
{
  function draw(count, vertexShaderFn) {
    const internalBuffer = [];
    for (let i = 0; i < count; ++i) {
      internalBuffer[i] = vertexShaderFn(i);
    }
    console.log(JSON.stringify(internalBuffer));
  }
  const shader = v => v * 2;
  draw(4, shader);
}

section('uniforms')
{
   function draw(count, vertexShaderFn, uniforms) {
     const internalBuffer = [];
     for (let i = 0; i < count; ++i) {
       internalBuffer[i] = vertexShaderFn(i, uniforms);
     }
     console.log(JSON.stringify(internalBuffer));
   }

   const vertexShader = (v, uniforms) => v * uniforms.multiplier;
   const count = 4;
   draw(count, vertexShader, {multiplier: 3});
   // outputs 0, 3, 6, 9
   draw(count, vertexShader, {multiplier: 5});
   // outputs 0, 5, 10, 15
}

section('attributes')
{
   function draw(count, vertexShaderFn, uniforms, attribsSpec) {
     const internalBuffer = [];
     for (let i = 0; i < count; ++i) {
       const attribs = getAttribs(attribsSpec, i);
       internalBuffer[i] = vertexShaderFn(i, uniforms, attribs);
     }
     console.log(JSON.stringify(internalBuffer));
   }

   function getAttribs(attribs, ndx) {
     return attribs.map(({source, offset, stride}) => source[ndx * stride + offset]);
   }

   const buffer1 = [0, 1, 2, 3, 4, 5, 6, 7, 8];
   const buffer2 = [11, 22, 33, 44];
   const attribsSpec = [
     { source: buffer1, offset: 0, stride: 2, },
     { source: buffer1, offset: 1, stride: 2, },
     { source: buffer2, offset: 0, stride: 1, },
   ];
   const vertexShader = (v, uniforms, attribs) => (attribs[0] + attribs[1]) * attribs[2];
   const uniforms = {};
   const count = 4;
   draw(count, vertexShader, uniforms, attribsSpec);

}

section('buffers')
{
   function getAttribs(attribs, ndx) {
     return attribs.map(({source, offset, stride}) => source[ndx * stride + offset]);
   }

   function draw(count, vertexShaderFn, uniforms, attribsSpec, bindings) {
     const internalBuffer = [];
     for (let i = 0; i < count; ++i) {
       const attribs = getAttribs(attribsSpec, i);
       internalBuffer[i] = vertexShaderFn(i, uniforms, attribs, bindings);
     }
     console.log(JSON.stringify(internalBuffer));
   }

   const buffer1 = [0, 1, 2, 3, 4, 5, 6, 7, 8];
   const buffer2 = [11, 22, 33, 44];
   const attribsSpec = [];
   const bindings = [
     buffer1,
     buffer2,
   ];
   const vertexShader = (ndx, uniforms, attribs, bindings) => 
       (bindings[0][ndx * 2] + bindings[0][ndx * 2 + 1]) * bindings[1][ndx];
   const uniforms = {};
   const count = 4;
   draw(count, vertexShader, uniforms, attribsSpec, bindings);
}

section('textures')
{
   function getAttribs(attribs, ndx) {
     return attribs.map(({source, offset, stride}) => source[ndx * stride + offset]);
   }

   function draw(count, vertexShaderFn, uniforms, attribsSpec, bindings) {
     const internalBuffer = [];
     for (let i = 0; i < count; ++i) {
       const attribs = getAttribs(attribsSpec, i);
       internalBuffer[i] = vertexShaderFn(i, uniforms, attribs, bindings);
     }
     console.log(JSON.stringify(internalBuffer));
   }

   function textureSample(texture, ndx) {
     const startNdx = ndx | 0;  // round down to an int
     const fraction = ndx % 1;  // get the fractional part between indices
     const start = texture[startNdx];
     const end = texture[startNdx + 1];
     return start + (end - start) * fraction;  // compute value between start and end
   }

   const texture = [10, 20, 30, 40, 50, 60, 70, 80];
   const attribsSpec = [];
   const bindings = [
     texture,
   ];
   const vertexShader = (ndx, uniforms, attribs, bindings) =>
       textureSample(bindings[0], ndx * 1.75);
   const uniforms = {};
   const count = 4;
   draw(count, vertexShader, uniforms, attribsSpec, bindings);
}

section('varyings: mapLine')
{
   for (const [p] of mapLine([10,10], [13, 13])) {
     console.log(p);
   }
}

section('varyings: output 2 values per iteration')
{
   function getAttribs(attribs, ndx) {
     return attribs.map(({source, offset, stride}) => source[ndx * stride + offset]);
   }

   function draw(count, vertexShaderFn, uniforms, attribsSpec, bindings) {
     const internalBuffer = [];
     for (let i = 0; i < count; ++i) {
       const attribs = getAttribs(attribsSpec, i);
       internalBuffer[i] = vertexShaderFn(i, uniforms, attribs, bindings);
     }
     console.log(JSON.stringify(internalBuffer));
   }

   const buffer1 = [5, 0, 25, 4];
   const attribsSpec = [
     {source: buffer1, offset: 0, stride: 2},
     {source: buffer1, offset: 1, stride: 2},
   ];
   const bindings = [];
   const vertexShader = (ndx, uniforms, attribs, bindings) => 
       [attribs[0], attribs[1]];
   const uniforms = {};
   const count = 2;
   draw(count, vertexShader, uniforms, attribsSpec, bindings);
}

section('varyings: draw line with constant value')
{
   function rasterizeLines(dest, destWidth, inputs, fragShaderFn, uniforms, bindings) {
     for(let ndx = 0; ndx < inputs.length - 1; ndx += 2) {
       const p0 = inputs[ndx    ];
       const p1 = inputs[ndx + 1]
       for (const [p] of mapLine(p0, p1)) {
         const offset = p[1] * destWidth + p[0];  // y * width + x
         dest[offset] = fragShaderFn(uniforms, bindings);
       }
     }
   }

   function getAttribs(attribs, ndx) {
     return attribs.map(({source, offset, stride}) => source[ndx * stride + offset]);
   }

   function draw(dest, destWidth,
                 count, vertexShaderFn, fragmentShaderFn,
                 uniforms, attribsSpec, bindings) {
     const internalBuffer = [];
     for (let i = 0; i < count; ++i) {
       const attribs = getAttribs(attribsSpec, i);
       internalBuffer[i] = vertexShaderFn(i, uniforms, attribs, bindings);
     }
     rasterizeLines(
         dest, destWidth, internalBuffer,
         fragmentShaderFn, uniforms, bindings);
   }

   const buffer1 = [5, 0, 25, 4];
   const attribsSpec = [
     {source: buffer1, offset: 0, stride: 2},
     {source: buffer1, offset: 1, stride: 2},
   ];
   const bindings = [];
   const vertexShader = (ndx, uniforms, attribs, bindings) => 
       [attribs[0], attribs[1]];
   const uniforms = {};
   const count = 2;

   const width = 30;
   const height = 5;
   const pixels = new Array(width * height).fill(0);
   const fragShader = (uniforms, bindings) => 6;

   draw(
      pixels, width,
      count, vertexShader, fragShader,
      uniforms, attribsSpec, bindings);
   logArray2D(pixels, width);      
}

section('varyings: draw line with varying value')
{
   function rasterizeLines(dest, destWidth, inputs, fragShaderFn, uniforms, bindings) {
     for(let ndx = 0; ndx < inputs.length - 1; ndx += 2) {
       const p0 = inputs[ndx    ][0];
       const p1 = inputs[ndx + 1][0];
       const v0 = inputs[ndx    ].slice(1);  // everything but the first value
       const v1 = inputs[ndx + 1].slice(1);
       for (const [p, t] of mapLine(p0, p1)) {
         const offset = p[1] * destWidth + p[0];  // y * width + x
         const varyings = interpolateArrays(v0, v1, t);
         dest[offset] = fragShaderFn(uniforms, bindings, varyings);
       }
     }
   }

   // interpolateArrays([[1,2]], [[3,4]], 0.25) => [[1.5, 2.5]]
   function interpolateArrays(v0, v1, t) {
     return v0.map((array0, ndx) => {
       const array1 = v1[ndx];
       return interpolateValues(array0, array1, t);
     });
   }

   // interpolateValues([1,2], [3,4], 0.25) => [1.5, 2.5]
   function interpolateValues(array0, array1, t) {
     return array0.map((a, ndx) => {
       const b = array1[ndx];
       return a + (b - a) * t;
     });
   }  

   function getAttribs(attribs, ndx) {
     return attribs.map(({source, offset, stride}) => source[ndx * stride + offset]);
   }

   function draw(dest, destWidth,
                 count, vertexShaderFn, fragmentShaderFn,
                 uniforms, attribsSpec, bindings,
    ) {
     const internalBuffer = [];
     for (let i = 0; i < count; ++i) {
       const attribs = getAttribs(attribsSpec, i);
       internalBuffer[i] = vertexShaderFn(i, uniforms, attribs, bindings);
     }
     rasterizeLines(dest, destWidth, internalBuffer,
                    fragmentShaderFn, uniforms, bindings);
   }

   const buffer1 = [5, 0, 25, 4];
   const buffer2 = [9, 3];
   const attribsSpec = [
     {source: buffer1, offset: 0, stride: 2},
     {source: buffer1, offset: 1, stride: 2},
     {source: buffer2, offset: 0, stride: 1},
   ];
   const bindings = [];
   const dest = new Array(2);
   const vertexShader = (ndx, uniforms, attribs, bindings) => 
       [[attribs[0], attribs[1]], [attribs[2]]];
   const uniforms = {};
   const count = 2;

   const width = 30;
   const height = 5;
   const pixels = new Array(width * height).fill(0);
   const fragShader = (uniforms, bindings, varyings) => varyings[0] | 0;

   draw(
      pixels, width,
      count, vertexShader, fragShader,
      uniforms, attribsSpec, bindings);
   logArray2D(pixels, width);      

}

function* mapLine(p1, p2) {
  const deltaInc = p1.map((v, ndx) => {
    const d = p2[ndx] - v;
    return {delta: Math.abs(d), inc: Math.sign(d)};
  });

  const mainAxis = deltaInc[0].delta > deltaInc[1].delta ? 0 : 1;
  const minAxis = 1 - mainAxis;
  const minDelta = deltaInc[minAxis].delta;
  const minInc = deltaInc[minAxis].inc;
  const mainInc = deltaInc[mainAxis].inc;

  let counter = deltaInc[mainAxis].delta;
  const endPnt = counter;
  const cursor = p1.slice();

  let accum = endPnt / 2;
  for (; counter > 0; --counter) {
    yield [cursor, 1 - (counter / endPnt)];
    accum += minDelta;
    if (accum >= endPnt) {
      accum -= endPnt;
      cursor[minAxis] += minInc;
    }
    cursor[mainAxis] += mainInc;
  }
}

function section(heading) {
  console.log(`\n======= [ ${heading} ] =======`);
}

function logArray2D(arr, width) {
  const lines = [];
  for (let i = 0; i < arr.length; i += width) {
    lines.push(arr.slice(i, i + width).map(v => v || '.').join(''));
  }
  console.log(lines.join('\n'));
}
</script>